#include <compiler/compiler.hpp>
#include <compiler/config.hpp>

// Add header guard head
static void guard_head(StringBuilder &header, const char *name)
{
    header.add("#ifndef ");
    header.add(name);
    header.add("\n");
    header.add("#define ");
    header.add(name);
    header.add("\n");
}

// Add header guard tail
static void guard_tail(StringBuilder &header)
{
    header.add("#endif\n");
}

// Add include
static void include(StringBuilder &source, const char *path)
{
    source.add("#include <");
    source.add(path);
    source.add(">\n");
}

// Add include with quotes
static void quoted_include(StringBuilder &source, const char *path)
{
    source.add("#include \"");
    source.add(path);
    source.add("\"\n");
}

// Add comment
static void comment(StringBuilder &builder, const char *content)
{
    builder.add("// ");
    builder.add(content);
    builder.add("\n");
}

// Get token type as string
static const char *token_type_as_string(unsigned int type)
{
    switch (type)
    {
        case token_void:
            return "void";

        case token_bool:
            return "bool";
            
        case token_ubyte:
            return "unsigned char";
            
        case token_ushort:
            return "unsigned short";
            
        case token_uint:
            return "unsigned int";
            
        case token_ulong:
            return "unsigned long long";
            
        case token_byte:
            return "char";
            
        case token_short:
            return "short";
            
        case token_int:
            return "int";
            
        case token_long:
            return "long long";
            
        case token_single:
            return "float";
            
        case token_double:
            return "double";
            
        case token_string_type:
            return "string_t";
    }
}

// Write type
static void type(StringBuilder &builder, Node *node)
{
    switch (node->type)
    {
        // Primitive type
        case node_primitive_type:
        {
            NodePrimitiveType &type_node = node->as_primitive_type;
            
            if (type_node.is_const)
                builder.add("const ");

            builder.add(token_type_as_string(type_node.token.type));
            builder.add(' ');       
            break;
        }
    }
}

// Write tabs
static void write_tabs(Compiler *compiler)
{
    for (unsigned int i = 0; i < compiler->tabs; ++i)
        compiler->c_source.add('\t');
}

// Compile primary expression
static void primary(Compiler *compiler, const ExpressionPrimary &primary)
{
    switch (primary.type)
    {
        // Number
        case primary_number:
        {
            compiler->c_source.add(static_cast<int64>(primary.as_number));
            break;
        }
    }
}

// Compile expression
static void expression(Compiler *compiler, const Expression &expression)
{
    switch (expression.type)
    {
        // Primary expression
        case expression_primary:
        {
            primary(compiler, expression.as_primary);
            break;
        }
    }
}

// Compile statement
static void statement(Compiler *compiler)
{
    Node &node = compiler->parser.ast.get(compiler->node_id++);

    switch (node.type)
    {
        // Return statement
        case node_return:
        {
            NodeReturn &return_node = node.as_return;
            write_tabs(compiler);

            if (!return_node.expression)
                compiler->c_source.add("return;\n");
            else
            {
                compiler->c_source.add("return ");
                expression(compiler, return_node.expression->as_expression);
                compiler->c_source.add(";\n");
            }

            break;
        }
    }
}

// Compile to C backend
void Compiler::compile_to_c(void)
{
    // Initialize the C header and source
    c_header.init();
    c_source.init();
    tabs = 0;

    // Generate header file
    guard_head(c_header, "NOG_MAIN_H");
    c_header.add('\n');
    comment(c_header, "File generated by the Nog compiler.");
    comment(c_header, "https://github.com/nog-lang/nog\n");

    for (node_id = 0; node_id < parser.ast.size; ++node_id)
    {
        Node &node = parser.ast.get(node_id);

        switch (node.type)
        {
            // Function declaration
            case node_function:
            {
                NodeFunction &function_node = node.as_function;

                // Make sure function isn't private
                if (function_node.property.type == token_private)
                    break;

                c_header.add("extern ");
                type(c_header, function_node.type);
                c_header.add(function_node.name.content);
                c_header.add("();\n");
                break;
            }
        }
    }

    c_header.add('\n');
    guard_tail(c_header);

    // Generate source file
    comment(c_source, "File generated by the Nog compiler.");
    comment(c_source, "https://github.com/nog-lang/nog\n");

    quoted_include(c_source, "main.h");
    c_source.add('\n');

    for (node_id = 0; node_id < parser.ast.size; ++node_id)
    {
        Node &node = parser.ast.get(node_id);

        switch (node.type)
        {
            // Function declaration
            case node_function:
            {
                NodeFunction &function_node = node.as_function;

                // Make sure function isn't extern
                if (function_node.property.type == token_extern || function_node.property.type != token_private)
                    break;
                
                c_source.add("static ");
                type(c_source, function_node.type);
                c_source.add(function_node.name.content);
                c_source.add("();\n");
                break;
            }
        }
    }

    for (node_id = 0; node_id < parser.ast.size; ++node_id)
    {
        Node &node = parser.ast.get(node_id);

        switch (node.type)
        {
            // Function declaration
            case node_function:
            {
                NodeFunction &function_node = node.as_function;

                // Make sure function isn't extern
                if (function_node.property.type == token_extern)
                    break;

                NodeBlock &block_node = function_node.block->as_block;

                ++tabs;
                c_source.add('\n');
                
                if (function_node.property.type == token_private)
                    c_source.add("static ");

                type(c_source, function_node.type);
                c_source.add(function_node.name.content);
                c_source.add("()\n{\n");

                while (node_id < block_node.last_id)
                    statement(this);

                c_source.add("}\n");
                --tabs;
                break;
            }
        }
    }

    // Write the output
    StringBuilder path;
    File          file;

    const char *header = c_header;
    const char *source = c_source;

    path.init();
    path.add(g_output);

    path.add("main.h");
    file.open(path);
    file.write(header);
    file.close();

    path.data[path.length - 1] = 'c';
    file.open(path);
    file.write(source);
    file.close();
}